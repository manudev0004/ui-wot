/*
  Generate component-oriented Markdown docs by copying each Stencil docs-readme
  (src/components/<cmp>/readme.md) into docs/components/<cmp>.md, and insert
  quick links to Properties/Events/Methods. Also write an index README listing
  all components.
*/

const fs = require('fs');
const path = require('path');

const ROOT = __dirname ? path.resolve(__dirname, '..') : process.cwd();
const SRC_COMPONENTS_DIR = path.join(ROOT, 'src', 'components');
const OUT_DIR = path.join(ROOT, 'docs', 'components');

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function readFileSafe(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (_) {
    return null;
  }
}

function writeFile(filePath, content) {
  ensureDir(path.dirname(filePath));
  fs.writeFileSync(filePath, content, 'utf8');
}

function makeTitleCase(tag) {
  // ui-button -> ui-button (keep tag), but for display we may show <ui-button>
  return `<${tag}>`;
}

function injectQuickLinks(markdown) {
  const linksLine = '[Properties](#properties) · [Events](#events) · [Methods](#methods)';
  if (markdown.includes(linksLine)) return markdown; // avoid duplicates

  const hasProps = /\n##\s+Properties\s*\n/i.test(markdown);
  const hasEvents = /\n##\s+Events\s*\n/i.test(markdown);
  const hasMethods = /\n##\s+Methods\s*\n/i.test(markdown);

  const parts = [];
  if (hasProps) parts.push('[Properties](#properties)');
  if (hasEvents) parts.push('[Events](#events)');
  if (hasMethods) parts.push('[Methods](#methods)');
  if (parts.length === 0) return markdown;

  const quickLinks = `\n\n${parts.join(' · ')}\n\n`;
  const lines = markdown.split(/\r?\n/);
  const h1Index = lines.findIndex(l => /^#\s+/.test(l));
  if (h1Index >= 0) {
    let insertAt = h1Index + 1;
    while (lines[insertAt] !== undefined && lines[insertAt].trim() === '') insertAt++;
    lines.splice(insertAt, 0, quickLinks.trim());
    return lines.join('\n');
  }
  return quickLinks + markdown;
}

function processComponent(tag) {
  const readmePath = path.join(SRC_COMPONENTS_DIR, tag, 'readme.md');
  const tsxPath = path.join(SRC_COMPONENTS_DIR, tag, `${tag}.tsx`);
  const md = readFileSafe(readmePath);
  if (!md) return null;

  // Extract examples from component JSDoc and @Method JSDoc
  const tsx = readFileSafe(tsxPath) || '';
  const classExamples = extractClassExamples(tsx);
  const methodExamples = extractMethodExamples(tsx);

  // Clean up unwanted sections
  let transformed = stripSections(md, [/^##\s+Shadow Parts\s*$/i, /^##\s+Dependencies\s*$/i]);
  // Also remove any "### Graph" mermaid blocks
  transformed = stripGraph(transformed);

  // Insert examples under Overview and per-method
  transformed = injectOverviewExamples(transformed, classExamples);
  transformed = injectMethodExamples(transformed, methodExamples);

  // Insert quick links (side index)
  const withLinks = injectQuickLinks(transformed);
  // Overwrite the component's readme.md so Stencil docs reflect enhanced content
  const outDir = path.join(SRC_COMPONENTS_DIR, tag);
  const outPath = path.join(outDir, 'readme.md');
  writeFile(outPath, withLinks);
  // Clean up any previous docs.md legacy file
  const legacy = path.join(outDir, 'docs.md');
  try {
    if (fs.existsSync(legacy)) fs.unlinkSync(legacy);
  } catch (_) {}
  return { tag, file: outPath };
}

function buildIndex(components) {
  const header = '# Components\n\n' + 'The following component docs include only decorated API surface (@Prop, @Event, @Method) and preserve your JSDoc comments.\n\n';
  const list = components.map(({ tag }) => `- [<${tag}>](../../src/components/${tag}/readme.md) — API, examples, Properties, Events, Methods`).join('\n');
  const footer =
    '\n\nTips:\n\n- Use the quick links at the top of each page to jump to Properties, Events, or Methods.\n- For utilities and services, see the API Reference generated by TypeDoc in ../typedoc/README.md.\n';
  return header + list + footer;
}

function main() {
  ensureDir(OUT_DIR);
  const entries = fs.readdirSync(SRC_COMPONENTS_DIR, { withFileTypes: true });
  const components = [];
  for (const dirent of entries) {
    if (!dirent.isDirectory()) continue;
    const tag = dirent.name; // e.g., ui-button
    const result = processComponent(tag);
    if (result) components.push(result);
  }
  components.sort((a, b) => a.tag.localeCompare(b.tag));
  const indexMd = buildIndex(components);
  writeFile(path.join(OUT_DIR, 'README.md'), indexMd);
  // Also write a short landing page into docs/README.md pointing to components and typedoc
  const docsRoot = path.join(ROOT, 'docs');
  const landing =
    '# UI-WoT Components Documentation\n\n' +
    '- Components (Stencil): [docs/components/](./components/README.md)\n' +
    '- Utils & Services (TypeDoc): [docs/typedoc/](./typedoc/README.md)\n';
  writeFile(path.join(docsRoot, 'README.md'), landing);
  console.log(`Generated component docs for ${components.length} components in ${OUT_DIR}`);
}

main();

// ---------------------------- helpers: examples & transforms ----------------------------

function extractClassExamples(tsx) {
  // Find the JSDoc block immediately preceding `export class` or `@Component` annotation
  // Capture @example sections with optional title and code fences
  const examples = [];
  const jsdocBlocks = Array.from(tsx.matchAll(/\/\*\*[\s\S]*?\*\//g)).map(m => m[0]);
  for (const block of jsdocBlocks) {
    if (!/\n\s*\*\s*@example\b/.test(block)) continue;
    // Heuristic: the block that contains overall component description will likely mention the component or be followed by @Component or export class
    // We'll collect examples from all blocks that have @example and are within the first 200 lines as a practical heuristic
    const startIdx = tsx.indexOf(block);
    if (startIdx > 2000) continue;
    examples.push(...parseExamplesFromJsdoc(block));
  }
  return examples;
}

function extractMethodExamples(tsx) {
  // Map method name -> list of examples (markdown)
  const map = new Map();
  // Find pairs of JSDoc + following method name line
  const regex = /\/\*\*[\s\S]*?\*\/\s*(?:@[A-Za-z]+\([^)]*\)\s*)*\s*(?:public\s+|private\s+|protected\s+)?(?:async\s+)?([a-zA-Z0-9_]+)\s*\(/g;
  let m;
  while ((m = regex.exec(tsx)) !== null) {
    const jsdoc = m[0].match(/\/\*\*[\s\S]*?\*\//)[0];
    const name = m[1];
    if (!/\n\s*\*\s*@example\b/.test(jsdoc)) continue;
    const examples = parseExamplesFromJsdoc(jsdoc);
    if (examples.length) {
      map.set(name, examples);
    }
  }
  return map;
}

function parseExamplesFromJsdoc(jsdoc) {
  // Convert JSDoc block to plain text lines by stripping leading *
  const body = jsdoc.replace(/^\/\*\*/, '').replace(/\*\/$/, '');
  const lines = body.split(/\r?\n/).map(l => l.replace(/^\s*\*\s?/, ''));
  const examples = [];
  let i = 0;
  while (i < lines.length) {
    if (/^@example\b/.test(lines[i])) {
      // Extract optional title after @example
      const title = lines[i].replace(/^@example\s*/i, '').trim();
      i++;
      const buff = [];
      // Collect until next @tag or end of block
      while (i < lines.length && !/^@[a-zA-Z]/.test(lines[i])) {
        buff.push(lines[i]);
        i++;
      }
      const content = buff.join('\n').trim();
      const sectionTitle = title ? `#### Example – ${title}` : '#### Example';
      const md = `${sectionTitle}\n\n${content}\n`;
      examples.push(md);
      continue;
    }
    i++;
  }
  return examples;
}

function stripSections(markdown, headingRegexes) {
  let result = markdown;
  for (const rx of headingRegexes) {
    result = stripSection(result, rx);
  }
  return result;
}

function stripSection(markdown, headingRx) {
  const lines = markdown.split(/\r?\n/);
  const start = lines.findIndex(l => headingRx.test(l));
  if (start === -1) return markdown;
  let end = start + 1;
  while (end < lines.length) {
    const l = lines[end];
    if (/^##\s+/.test(l)) break; // next H2 section
    end++;
  }
  lines.splice(start, end - start);
  return lines.join('\n');
}

function stripGraph(markdown) {
  // Remove any "### Graph" heading and the subsequent mermaid code block
  const lines = markdown.split(/\r?\n/);
  const idx = lines.findIndex(l => /^###\s+Graph\s*$/i.test(l));
  if (idx === -1) return markdown;
  let end = idx + 1;
  // Remove until the end of mermaid code block and the dashed separator
  let inCode = false;
  while (end < lines.length) {
    const l = lines[end];
    if (/^```/.test(l)) inCode = !inCode;
    if (!inCode && /^-{5,}\s*$/.test(l)) {
      end++;
      break;
    }
    if (!inCode && /^##\s+/.test(l)) break;
    end++;
  }
  lines.splice(idx, end - idx);
  return lines.join('\n');
}

function injectOverviewExamples(markdown, examples) {
  if (!examples || !examples.length) return markdown;
  const lines = markdown.split(/\r?\n/);
  const overviewIdx = lines.findIndex(l => /^##\s+Overview\s*$/i.test(l));
  if (overviewIdx === -1) return markdown;
  // Find insertion point: after overview content but before next H2
  let insertAt = overviewIdx + 1;
  while (insertAt < lines.length && !/^##\s+/.test(lines[insertAt])) insertAt++;
  const block = ['\n### Examples\n', ...examples.map(e => e.trim()), ''];
  lines.splice(insertAt, 0, ...block);
  return lines.join('\n');
}

function injectMethodExamples(markdown, methodExampleMap) {
  if (!methodExampleMap || methodExampleMap.size === 0) return markdown;
  const lines = markdown.split(/\r?\n/);
  // find Methods section start and end to limit processing
  const methodsStart = lines.findIndex(l => /^##\s+Methods\s*$/i.test(l));
  if (methodsStart === -1) return markdown;
  let i = methodsStart + 1;
  while (i < lines.length) {
    if (/^##\s+/.test(lines[i])) break; // end of methods section
    const methodHeader = lines[i].match(/^###\s+`([^`(]+)\s*\(/);
    if (methodHeader) {
      const name = methodHeader[1];
      const examples = methodExampleMap.get(name) || methodExampleMap.get(name.replace(/^async\s+/, ''));
      if (examples && examples.length) {
        // Find description end (before first #### Parameters/Returns)
        let insertAt = i + 1;
        while (insertAt < lines.length && !/^####\s+(Parameters|Returns)/.test(lines[insertAt]) && !/^###\s+`/.test(lines[insertAt]) && !/^##\s+/.test(lines[insertAt])) {
          insertAt++;
        }
        const block = ['', '#### Example', '', ...examples.map(e => e.replace(/^#### Example.*\n/, '').trim()), ''];
        lines.splice(insertAt, 0, ...block);
        i = insertAt + block.length;
        continue;
      }
    }
    i++;
  }
  return lines.join('\n');
}
