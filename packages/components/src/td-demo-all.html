<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Minimal All-Components TD Demo</title>
    <style>
      body {
        font-family: system-ui, -apple-system, sans-serif;
        max-width: 900px;
        margin: 28px auto;
        padding: 18px;
        background: #f8fafc;
      }
      .card {
        background: #fff;
        padding: 16px;
        border-radius: 10px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.06);
      }
      .row {
        display: flex;
        gap: 14px;
        align-items: center;
        margin: 14px 0;
      }
      h1 {
        margin: 0 0 12px;
      }
      .meta {
        color: #6b7280;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>Clean TD Demo with Component Methods</h1>
      <p class="meta">
        Using <strong>Node-WoT</strong> to handle TD consumption and component methods (<code>setValue</code>, <code>getValue</code>, <code>setStatus</code>) for proper separation of concerns.
        <br>Components are pure UI elements, TD integration handled entirely in HTML/JavaScript.
      </p>

      <div class="row">
        <div>
          <h3>Toggle (bool)</h3>
          <ui-toggle
            id="td-toggle"
            label="TD Toggle"
            show-last-updated="true"
            show-status="true"
          ></ui-toggle>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Slider (num)</h3>
          <ui-slider
            id="td-slider"
            min="0"
            max="100"
            label="TD Slider"
            show-last-updated="true"
            show-status="true"
          ></ui-slider>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Number Picker (int)</h3>
          <ui-number-picker
            id="td-number"
            min="0"
            max="100"
            label="TD Number"
            show-last-updated="true"
            show-status="true"
          ></ui-number-picker>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Button</h3>
          <ui-button 
            id="td-button" 
            label="TD Button" 
            show-last-updated="true" 
            show-status="true"
          ></ui-button>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Checkbox (bool)</h3>
          <ui-checkbox
            id="td-checkbox"
            label="TD Checkbox"
            show-last-updated="true"
            show-status="true"
          ></ui-checkbox>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Text (string)</h3>
          <ui-text
            id="td-text"
            label="TD Text"
            show-last-updated="true"
            show-status="true"
          ></ui-text>
        </div>
      </div>

      <div class="row">
        <div>
          <h3>Calendar (date)</h3>
          <ui-calendar
            id="td-calendar"
            label="TD Calendar"
            show-last-updated="true"
            show-status="true"
          ></ui-calendar>
        </div>
      </div>

      <div class="meta">Open the browser console to see events and status messages.</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@node-wot/browser-bundle@latest/dist/wot-bundle.min.js"></script>
    <script type="module" src="./build/ui-wot-components.esm.js"></script>

    <script>
      // Clean TD handling with Node-WoT, utilizing component methods properly
      (async function () {
        console.log('üöÄ Starting TD Demo - using component methods properly');
        
        // Wait for all components to be defined
        const COMPONENT_TAGS = ['ui-toggle', 'ui-slider', 'ui-number-picker', 'ui-button', 'ui-checkbox', 'ui-text', 'ui-calendar'];
        await Promise.all(COMPONENT_TAGS.map(tag => customElements.whenDefined(tag)));
        console.log('‚úÖ All components ready');

        // Initialize WoT with timeout
        if (!window.WoT) {
          console.error('‚ùå WoT library not loaded');
          return;
        }

        // Create WoT runtime
        const servient = new window.WoT.Core.Servient();
        servient.addClientFactory(new window.WoT.Http.HttpClientFactory());
        const wot = await servient.start();
        console.log('‚úÖ WoT Servient started');

        // Fetch and consume TD
        const tdUrl = 'http://plugfest.thingweb.io/http-data-schema-thing';
        let thing;
        try {
          console.log('üì° Fetching TD from:', tdUrl);
          const response = await fetch(tdUrl);
          const tdJson = await response.json();
          thing = await wot.consume(tdJson);
          console.log('‚úÖ TD consumed successfully');
          console.log('üìã Available properties:', Object.keys(tdJson.properties || {}));
        } catch (error) {
          console.error('‚ùå Failed to fetch/consume TD:', error);
          return;
        }

        // Define component bindings using proper component methods
        const bindings = [
          { 
            element: document.getElementById('td-toggle'), 
            property: 'bool',
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          },
          { 
            element: document.getElementById('td-slider'), 
            property: 'num',
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          },
          { 
            element: document.getElementById('td-number'), 
            property: 'int',
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          },
          { 
            element: document.getElementById('td-checkbox'), 
            property: 'bool',  // Note: both toggle and checkbox use same 'bool' property
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          },
          { 
            element: document.getElementById('td-text'), 
            property: 'string',
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          },
          { 
            element: document.getElementById('td-calendar'), 
            property: 'date',
            getValue: (el) => el.getValue(),
            setValue: (el, val) => el.setValueSilent(val),
            setStatus: (el, status, msg) => el.setStatus(status, msg),
            triggerPulse: (el) => el.triggerReadPulse()
          }
        ].filter(binding => binding.element);

        console.log(`üîó Created ${bindings.length} component bindings`);

        // Track write operations per property to avoid conflicts
        const writeOperations = new Map();

        // Read initial values using Node-WoT
        console.log('üì• Reading initial values...');
        for (const binding of bindings) {
          try {
            const propertyValue = await thing.readProperty(binding.property);
            const value = await propertyValue.value();
            await binding.setValue(binding.element, value);
            await binding.setStatus(binding.element, 'success');
            await binding.triggerPulse(binding.element);
            console.log(`‚úÖ ${binding.property}:`, value);
          } catch (error) {
            console.error(`‚ùå Failed to read ${binding.property}:`, error);
            await binding.setStatus(binding.element, 'error', `Read failed: ${error.message}`);
          }
        }

        // Set up value change listeners
        bindings.forEach(binding => {
          binding.element.addEventListener('valueMsg', async (event) => {
            const newValue = event.detail.payload;
            const property = binding.property;
            
            console.log(`üì§ Component ${binding.element.id} changed ${property} to:`, newValue);
            
            // Prevent concurrent writes to same property
            if (writeOperations.has(property)) {
              console.log(`‚è≥ Write to ${property} already in progress, skipping`);
              return;
            }
            
            // Mark write as in progress
            writeOperations.set(property, true);
            
            try {
              await binding.setStatus(binding.element, 'loading');
              await thing.writeProperty(property, newValue);
              await binding.setStatus(binding.element, 'success');
              console.log(`‚úÖ Successfully wrote ${property}:`, newValue);
            } catch (error) {
              console.error(`‚ùå Failed to write ${property}:`, error);
              await binding.setStatus(binding.element, 'error', `Write failed: ${error.message}`);
              
              // Revert to last known good value
              try {
                const currentValue = await thing.readProperty(property);
                const value = await currentValue.value();
                await binding.setValue(binding.element, value);
                console.log(`üîÑ Reverted ${property} to:`, value);
              } catch (revertError) {
                console.error(`‚ùå Failed to revert ${property}:`, revertError);
              }
            } finally {
              // Clear write operation flag
              writeOperations.delete(property);
            }
          });
        });

        // Button handler (actions don't have state)
        const buttonElement = document.getElementById('td-button');
        if (buttonElement) {
          buttonElement.addEventListener('valueMsg', async (event) => {
            console.log('üîò Button clicked:', event.detail);
            await buttonElement.setStatus('success');
            // You could invoke TD actions here if the TD had any
          });
        }

        // Event-driven updates using Node-WoT property observation
        const subscriptions = [];
        window.addEventListener('beforeunload', () => {
          // Clean up subscriptions
          subscriptions.forEach(sub => {
            try {
              sub.stop();
            } catch (e) {
              console.log('Subscription cleanup:', e.message);
            }
          });
          console.log('üõë Cleaned up all subscriptions');
        });

        const setupEventDrivenUpdates = async () => {
          console.log('ÔøΩ Setting up event-driven updates...');
          
          for (const binding of bindings) {
            try {
              // Check if property supports observation
              const tdProperty = consumedTD.properties[binding.property];
              if (tdProperty && tdProperty.observable !== false) {
                console.log(`üîî Subscribing to ${binding.property} changes`);
                
                const subscription = await thing.observeProperty(binding.property, async (data) => {
                  try {
                    const newValue = await data.value();
                    const currentValue = await binding.getValue(binding.element);
                    
                    // Only update if value actually changed
                    if (newValue !== currentValue) {
                      await binding.setValue(binding.element, newValue);
                      await binding.triggerPulse(binding.element);
                      await binding.setStatus(binding.element, 'success');
                      console.log(`ÔøΩ Event update ${binding.property}:`, newValue);
                    }
                  } catch (error) {
                    console.error(`‚ùå Event update error for ${binding.property}:`, error);
                    await binding.setStatus(binding.element, 'error', `Update failed: ${error.message}`);
                  }
                });
                
                subscriptions.push(subscription);
              } else {
                console.log(`‚ÑπÔ∏è ${binding.property} not observable, using fallback polling`);
                // Fallback to less frequent polling for non-observable properties
                setupFallbackPolling(binding);
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è Failed to observe ${binding.property}:`, error.message);
              // Fallback to polling for this property
              setupFallbackPolling(binding);
            }
          }
        };

        // Fallback polling for non-observable properties (much less frequent)
        const setupFallbackPolling = (binding) => {
          const pollProperty = async () => {
            try {
              const propertyValue = await thing.readProperty(binding.property);
              const currentValue = await propertyValue.value();
              const componentValue = await binding.getValue(binding.element);
              
              if (currentValue !== componentValue) {
                await binding.setValue(binding.element, currentValue);
                await binding.triggerPulse(binding.element);
                await binding.setStatus(binding.element, 'success');
                console.log(`üîÑ Fallback update ${binding.property}:`, currentValue);
              }
            } catch (error) {
              console.warn(`‚ö†Ô∏è Fallback poll error for ${binding.property}:`, error.message);
              await binding.setStatus(binding.element, 'error', `Poll failed: ${error.message}`);
            }
            
            // Much less frequent polling (every 30 seconds)
            setTimeout(pollProperty, 30000);
          };
          
          // Start fallback polling after a delay
          setTimeout(pollProperty, 10000);
        };

        // Start event-driven updates
        await setupEventDrivenUpdates();
        console.log('üéâ TD Demo initialized successfully');
      })();
    </script>
  </body>
</html>
