<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ui-toggle</title>
    <style>
      body { font-family: system-ui, -apple-system, sans-serif; max-width:800px; margin:36px auto; padding:18px; background:#f8fafc }
      .card { background:white; padding:20px; border-radius:10px; box-shadow:0 1px 3px rgba(0,0,0,.06) }
      .row { display:flex; gap:18px; align-items:center; margin-bottom:14px }
      .meta { color:#6b7280; font-size:13px }
    </style>
  </head>
  <body>
    <div class="card">
      <h1>ui-toggle TD demo (simplified)</h1>
      <p class="meta">Uses current attributes: <code>td-url</code>, <code>td-property</code>, <code>sync-interval</code>, <code>mode</code>, <code>mirror</code></p>

      <div class="row">
        <div>
          <h3>Controller (readwrite)</h3>
          <ui-toggle id="readwrite-toggle" mode="readwrite" td-property="bool" td-url="http://plugfest.thingweb.io/http-data-schema-thing" sync-interval="3000" label="Controller"></ui-toggle>
        </div>
  <div class="meta">Property: <strong>bool</strong></div>
      </div>

      <div class="row">
        <div>
          <h3>Monitor (read-only)</h3>
          <ui-toggle id="readonly-toggle" mode="read" mirror="#readwrite-toggle" sync-interval="3000" variant="square" label="Monitor"></ui-toggle>
        </div>
  <div class="meta">Property: <strong>bool</strong></div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@node-wot/browser-bundle@latest/dist/wot-bundle.min.js"></script>
    <script type="module" src="./build/ui-wot-components.esm.js"></script>

    <script>
      // Minimal wiring: only the controller is wired to the TD. The readonly monitor mirrors
      // the controller via `mirror="#readwrite-toggle"` and requires no extra JS.
      const TD_URL = 'http://plugfest.thingweb.io/http-data-schema-thing';
  const RW = document.getElementById('readwrite-toggle');

      async function waitForWoT() {
        while (!window.WoT) await new Promise(r => setTimeout(r, 100));
        return window.WoT;
      }

      document.addEventListener('DOMContentLoaded', async () => {
        try {
          const WoT = await waitForWoT();
          const servient = new WoT.Core.Servient();
          servient.addClientFactory(new WoT.Http.HttpClientFactory());
          const wot = await servient.start();

          const res = await fetch(TD_URL);
          if (!res.ok) throw new Error('TD fetch failed ' + res.status);
          const td = await res.json();
          const thing = await wot.consume(td);

          const prop = RW.getAttribute('td-property');
          if (!prop) return;

          // initial read
          const p = await thing.readProperty(prop);
          const initial = Boolean(await p.value());
          if (typeof RW.applyExternalValue === 'function') RW.applyExternalValue(initial); else RW.value = initial;

          // observe updates. If the TD doesn't provide an observable form for this property
          // (some HTTP TDs don't), fall back to a simple polling loop instead of failing.
          try {
            await thing.observeProperty(prop, async data => {
              const v = Boolean(await data.value());
              if (typeof RW.applyExternalValue === 'function') RW.applyExternalValue(v); else RW.value = v;
            });
          } catch (observeErr) {
            console.warn('observeProperty failed, falling back to polling:', observeErr.message || observeErr);
            // Poll every 3 seconds
            const pollInterval = 3000;
            const poller = setInterval(async () => {
              try {
                const p2 = await thing.readProperty(prop);
                const v2 = Boolean(await p2.value());
                if (typeof RW.applyExternalValue === 'function') RW.applyExternalValue(v2); else RW.value = v2;
              } catch (pollErr) {
                console.warn('Polling readProperty failed:', pollErr.message || pollErr);
              }
            }, pollInterval);
            // store poller on the element so it can be cleared externally if needed
            RW.__td_poller = poller;
          }

          // write when controller emits valueChange
          RW.addEventListener('valueChange', async e => {
            try { await thing.writeProperty(prop, Boolean(e.detail?.value)); } catch (err) { console.error('write failed', err); }
          });
        } catch (err) {
          console.error('TD wiring failed', err);
        }
      });
    </script>
  </body>
</html>
